<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--
        React Home -> 문서 -> 웹사이트에 react 추가하기 -> 2단계_스크립트 태그 추가하기
        외부 파일을 불러오는 script의 경우 head 안에 작성해준다.
    -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <!--babel-->
    <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>

<body>
    <!--
        Hooks는 리액트 16.8에서 새로 도입된 기능으로 함수 컴포넌트에서 사용 불가능한 메소드의 한계점으로
        인해 상태 관리 및 렌더링 이후 시점 컨트롤 등 다양한 문제를 해결하기 위해 만든 함수 집합을 의미한다
        그중 useState는 가장 기본적인 hook이며 함수 컴포넌트에서도 상태를 관리할 수 있게 해준다

        컴포넌트가 렌더링 된 이후 특정 작업을 수행할 필요가 있다면 클래스형 컴포넌트에서는
        componentDidMount 혹은 omponentDidUpdate 메소드를 이용하면 된다
        하지만 함수형 컴포넌트에서 생명주기 api 사용이 불가능하다
        그렇기 때문에 함수형 컴포넌트에서도 렌더링 된 이후 시점에 수행 할 내용이 필요한 경우 사용할 수 있는 
        기능을 hooks로 제공하고 있고 useEffect이다 
    -->
    <div id="root"></div>
    <script type="text/babel">
        const { useEffect } = React;

        function MessagePrint({ message }) {
            /* 실행순서 01. */
            console.log("렌더링...");

            /* 실행순서 03. */
            useEffect(() => {
                console.log("렌더링 이후 동작");
                console.log(message);
            });

            /* render()로 작성하는거랑 동일 현재는 감추고 있음 */
            /* 실행순서 02. */
            return (
                <h1>{console.log("렌더링 시 동작됨")} {message}</h1>
            );
            /*
                함수형 컴포넌트는 기본적으로 return을 만나면 이후 실행을 무시하기 때문에
                useEffect가 return(render) 이후에 실행이 되지만 return 구문 위에 작성을
                해야 한다
            */
        }
        const message = "안녕하세요";
        ReactDOM.createRoot(document.getElementById("root")).render(<MessagePrint message={message} />);
    </script>
</body>

</html>